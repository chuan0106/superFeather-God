# Project

1.  目录结构划分

2.  引用了两个 css 文件

3.  vue.config.js 和.editorconfig

4.  项目的模块划分：tabbar=>路由映射关系

5.  首页开发

6.  navbar 的封装

7.  网络数据的请求

8.  轮播图

9.  推荐信息

## 1.FeatureView

独立组件封装 FeatureView

## 2.TabControl

独立组件的封装

## 3.首页商品数据的请求

1. 设计数据结构 用于保存数据
2. 发送数据请求

## 4.对商品数据进行展示

1. 封装 GoodsList.vue 组件
2. 封装 GoodsListItem.vue 组件

## 5.对滚动进行重构:Better-Scroll

1. 在 index.html 中使用 Better-Scroll
2. 在 Vue 项目中使用 Better-Scroll

## 6.回到顶部 BackTop

1. 对 BackTop.vue 组件的封装
2. 如何监听组件的点击
3. BackTop 组件的显示隐藏

## 7.解决首页中 Better-Scroll 可滚动区域的问题

observeDOM: true,
observeImage: true,
[详情查看官网](https://better-scroll.github.io/docs/en-US/)

## 7.5 另一种

如何将 GoodsListTItem.vue 中的事件传入 Home.vue 中

- 因为涉及到非父子组件的通信 所以这里我们选择了事件总线
  可以作为一个简单的组件传递数据，用于解决跨级和兄弟组件通信问题
  `main.js`

```JavaScript
添加原型
Vue.prototype.$bus = new Vue()

发送事件
 methods: {
    imageLoad() {
      // 检测图片加载完成
      // console.log('imageLoad');
      // 事件总线
      // 现在没什么作用 留着下次知道这个是干嘛的
      this.$bus.$emit('itemImageLoad');
    },
  },

接收事件
   mounted() {
    this.$bus.$on('itemImageLoad', () => {
    this.$refs.scroll && this.$refs.scroll.refresh();
    });
  },
```

- 对于 refresh 非常繁琐的问题 进行防抖操作
  防抖(debounce)和节流(throttle)
  防抖函数起作用的过程
  - 1.如果我们直接执行 refresh，那么 refresh 函数会被执行 30 次
  - 2.可以将 refresh 函数传入到 debounce 函数中生成一个新的函数
  - 3.之后调用非常频繁的时候 就会使用新生成的函数
  - 4.而新生成的函数 并不会非常频繁的调用 如果下一次执行来的非常快 name 会将上一次取消掉

## 防抖和节流在项目中应该会经常使用

自行查询

```JavaScript
  // 封装防抖函数
    debounce(func, delay) {
      let timer = null;
      return function(...args) {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
          func.apply(this, args);
        }, delay);
      };
```

# 8.上拉加载更多的功能

# 9.tabControl 的吸顶效果

9.1. 获取到 tabControl 的 offsetTop
必须知道滚动多少时 开始有吸顶效果 这个时候就需要获取 tabControl 的 offsetTop
但是如果直接在 mounted 中获 tabControl 的 offsetTop name 值是不正确的 因为是没有将图片计算在内的

- 如何获取正确的值呢
  监听 HomeSwiper 中的 img 加载完成
  加载完成后 法师事件 在 Home.vue 中 获取争取的值

- 补充
  为了不让 HomeSwiper 多次发出事件
  可以使用 isLoad 的变量进行状态的记录

- 注意:这里不进行多次调用 debounce 的区别

  9.2 监听滚动 动态的改变 tabControl 的样式

- 问题:动态的改变 tabControl 的样式时 会出现两个问题

1.  下面的商品内容 会突然上移
2.  tabControl 虽然设置了 fixed 但是也随着 Better:Scroll 一起滚出去了

- 其他方案解决停留问题
  在最上面 多复制一份 PlaceHolderTabControl 组件对象 利用他来实现停留效果
  当我们用户滚动一定位置时,PlaceHolderTabControl 显示出来
  当用户滚动没有达到一定位置时 PlaceHolderTabControl 隐藏起来

# 10 让 Home 保持原来的状态

10.1 让 Home 不要随意销毁掉
keep-alive
10.2 让 Home 中的内容保持原来的位置

- 离开时保存一个位置信息
- 进来时 将位置设置为原来的位置信息即可
  注意:最好回来时 进行一次 refresh()

# 详情页实现思路

# 1.点击商品进入详情页

GoodsListitem 点击
点击之后获取商品的 iid 跳转到详情页 并且传入 iid

# 2.解决-首页保持位置状态

deactivated 记录离开时的位置
activated 通过 scrollTo 函数 设置离开时的位置

# 3.详情页的导航栏实现

返回按钮:left
标题列表的展示 center

# 4.请求详情的数据

接口:/detail?iid=

# 5.轮播图的实现

Swiper/Swiperitem

# 6.商品基本信息展示

数据来自四面八方
对数据进行汇总:一个对象当中
一个对象传入子组件

# 7.店铺信息的展示

###

# 8.商品图片的展示

###

# 9.参数信息的展示

老师上课遇到遍历的问题

# 10.评论信息的展示

时间格式化
服务器返回的时间戳=>date=>格式化
yyyy-MM-dd:mm:ss

可以利用插件 moment 时间格式化

# 11.推荐数据的展示

请求推荐的数据
GoodsList 展示数据

# 12.mixin 的使用

很多组件有共享代码可以进行抽取
创建混入对象:const mixin ={}
组件对象:mixins:[mixin]

# 13.处理两个 bug

首页 tabControl
详情滚动的 bug

# 14.标题和内容的联动效果

14.1 点击标题 滚动到对应的主体

- 在 detail 中监听标题的点击 获取 index
- 滚动到对应的主体

  - 获取所有主体的 offsetTop
  - 在哪里可以获取争取的 offsetTop
  - 1. created 肯定不行 压根不能获取元素
  - 2. mounted 也不行 数据还没获取到
  - 3. 获取数据的回调中也不行 DOM 还没渲染完
  - 4. \$nextTick 也不行 因为图片的高度没有被计算在内
  - 5. 在图片加载完成后 获取的高度才是正确的

       14.2 内容滚动 显示正确的标题

```JavaScript
普通做法:
    length  [0, 7911, 8546, 8857]

 if (
          this.currentIndex !== i &&
          ((i < length - 1 &&
            positionY >= this.themTopYs[i] &&
            positionY <= this.themTopYs[i + 1]) ||
            (i === length - 1 && positionY > this.themTopYs[i]))
        ) {
          this.currentIndex = i;
          console.log(this.currentIndex);
          this.$refs.navBar.currentIndex = this.currentIndex;
        }
        条件成立: this.currentIndex = i;
        条件1:防止赋值的条件过于频繁
        条件2: ((i < length - 1 &&
            positionY >= this.themTopYs[i] &&
            positionY <= this.themTopYs[i + 1]) ||
            (i === length - 1 && positionY > this.themTopYs[i]))
            条件1：(i < length - 1 &&
            positionY >= this.themTopYs[i] &&
            positionY <= this.themTopYs[i + 1])
            判断区间:在 0 和某个数字之间(i < length -1>)
            条件2: (i === length - 1 && positionY > this.themTopYs[i]))
            判断大于等于: i ===length - 1

hack做法:  所以 length要 -1
 length  [0, 7911, 8546, 8857,特别大的值]
  for (let i = 0; i < length - 1; i++) {
        if (
          this.currentIndex !== i &&
          positionY >= this.themTopYs[i] &&
          positionY < this.themTopYs[i + 1]
        ) {
          this.currentIndex = i;
          console.log(this.currentIndex);
          this.$refs.navBar.currentIndex = this.currentIndex;
        }
```

1. 底部工具栏 点击加入购物车
2. 回到顶部
